
优质劳动力不是在最佳实践下运行，也无法达到最佳的工作状态。

<mark style="background: #BBFABBA6;">软件过程是软件产品【成本，进度，和质量】的主要决定因素。</mark>  
是构造高质量软件需要完成的任务框架。

## 软件过程的定义和作用

defines who is doing what.  when to do it.  and how to reach a certain goal.

软件过程也称为软件生存周期过程，是指软件生存周期中的一系列相关的过程。  

- 其中，过程就是活动的集合，活动是任务的集合，任务起到把输入加工成输出的作用。  
- 活动的执行可以是顺序的，迭代的（重复的），并行的，嵌套的，或者是有条件的引发的。


什么是软件生存周期模型：

![image.png](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250306184646802.png)

## 软件过程的分类

软件是系统中的一部分，软件需求从系统需求和设计中导出。  
开发的软件最终被集成到系统中，软件过程和系统过程紧密相关。分别定义了系统过程和软件过程。

![f00fea1eb616acaf3d831c486e29cbd4_720.jpg](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250304123102287.jpg)

- 协议过程，组织项目使能过程，项目过程，技术过程，【软件过程】软件实现过程，软件支持过程，软件复用过程。

软件过程的核心元素：

- 活动：是过程的核心
- 任务：是活动的细分
- 工件：是软件过程的工作产品。
- 角色
- 资源
- 目标：每一个过程都有其明确的目标。
- 度量目标：过程目标的具体测量和分析。

## 软件生命周期模型。

### 瀑布模型：waterfall model

main：

![image.png](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250306185138224.png)

detail：

将软件过程中的各项活动规定为依固定的顺序连接的若干阶段工作，形如瀑布流水。最终得到软件产品。  
没有一个阶段的结束都设有评审，只有通过评审，才能进入到后一个阶段。前一个节点的中间产品成为后一个阶段工作的基础。

![Screenshot_20250304_124313_Samsung capture.jpg](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250304124324683.jpg)

瀑布模型可以广泛流行的原因：  
1：由于他在支持开发结构化软件，控制软件开发复杂度，促进软件开发工程化中起到了显著的作用。  
2：由于他为软件开发维护提供了一种当时较为有效的管理模式，通过开发计划的制订，项目估算，阶段评审，和文档控制有效的对软件过程进行指导。从而对软件质量有一定程度的保证。

但是，瀑布模型的最大问题在于没有在实践中进行验证。一个没有通过验证的模型会在大量的实践中暴露出他的种种不足和问题。

- 用户常常难以清楚的给出所有的需求。而瀑布模型却要求如此，他不能接受在许多项目的开始阶段自然存在的不确定性，以及开发过程中的需求变更。
- 错误发现太迟。软件的运行版本一直要等到项目开发晚期才可以得到，很多错误直到运行程序的时候才会发现，从而造成大量的返工。
- 开发进度太慢。 由于模型是线性的，开发者常常被不必要的耽搁，某些项目组成员不得不等待组内其他成员先完成其所依赖的任务。

所以当以下的情况，就不要使用瀑布模型：

- 需求没有被充分的理解。
- 系统太大不能一次开发完成。
- 事先打算采用的技术迅速发生变化。
- 需求迅速发生变化。
- 资源有限，现有的人员、资金不足。
- 无法利用某一个中间的产品。

太过理想化，太单纯，已经不再适合当前充满各种风险的软件开发项目。几乎已经被抛弃。  
增量模型和演化模型实质上就是多次重复的线性模型。 应该灵活运用。 当开发技术足够成熟的时候，线性模型可能会再次回归到业界实践中。

### 增量模型 incremental model

main：  
![image.png](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250306185817044.png)



detail：

又称为有计划的产品改进模型，从一组给定的需求开始，通过构造一系列可执行版本来实施开发活动。  
第一个版本纳入一部分需求，下一个版本纳入更多的需求，以此类推，直到系统的完成。  
每一个版本都要执行必要的过程，活动和任务，如需求分析和架构设计只需要执行一次，而软件详细设计，软件编码和测试，软件集成和软件验收，在每一个版本构造过程 中都会执行。

![Screenshot_20250304_130522_Samsung capture.jpg](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250304130615556.jpg)

和瀑布模型相比，有以下的特点：

- 多个版本可以并行的开发。在开发每一个版本的时候，开发过程中的活动和任务顺序或部分的平行的进行。
- 每一个版本都是可以运行的产品。 每一个线性序列产生软件的一个可发布的增量，他必须是可以运行的产品。
- 需求在开发早期是明确的。大部分发需求在项目早期就被定义，在此基础上进行整体架构的设计，然后将功能有计划的分为若干的增量来逐步的实现。

当开发人员，资源或者资金不足以在一个设定的期限内实现一个完全的版本的时候，增量开发就很有用。  
早期的增量可以由较少的人员实现，如果核心产品很受欢迎，可以增加新的人手实现下一个增量。  
同时，增量可以有计划的管理技术风险，并且能够提前把产品推向市场。

但增量并没有缓解瀑布模型无法很好处理的需求风险，相反，一旦需求不明确或者需求变更频繁，返工的风险会更大，极可能涉及到多个并行开发的版本。  
因此，在下列情况下，不建议使用增量模型。

- 需求没有被很好的理解。
- 突然提出一些功能。
- 事先打算采用的技术迅速发生变化，
- 需求迅速的发生变化。
- 在比较长的时间内没有充足的资源保证。（工作人员/资金）

<mark style="background: #BBFABBA6;">在下列情况下，可以使用。</mark>

- 需要早期获得功能。
- 中间产品可以提供使用。
- 系统被自然的分割为增量。
- 工作人员/资金，可以逐步的增加。

### 演化模型 evolutionary model

main：  
![image.png](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250306185917476.png)  
![image.png](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250306190427119.png)


detail：

业务和产品需求在软件开发过程中常常发生改变，只进行一次迭代就开发出最终的产品是不可能的  
同时，紧迫的市场期限是的一个完善的产品难以一下子完成。  
因此，只要核心需求能够很好的被理解。就可以进行渐进式的开发，其余需求则在后续的迭代中进一步定义和实现，这种过程模型称为演化模型

他能够很好的适应随着时间演化的产品的开发。

![Screenshot_20250304_134358_Samsung capture.jpg](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250304134411468.jpg)

2：允许需求的变更。 通过向用户演示迭代所产生的部分系统功能，可以尽早的收集用户对系统的反馈，及时的改正对用户需求的理解偏差，从而保证开发出来的系统能够真正的解决用户的问题。

演化模型是目前采用最广泛的模型， 统一过程（unified process）和许多敏捷过程都采用了这种模型。  
有一个明显的缺点：复杂。  
比瀑布模型复杂很多，其难点是迭代的规划和控制，这也是其成功的关键。

【迭代开发原则：】

迭代是处理不确定的复杂问题的有效手段。  
将一个软件生命周期划分为若干个迭代，前一个迭代将为下一个迭代积累经验。

原则一：  
<mark style="background: #BBFABBA6;">要求每次迭代都产生一个可以执行的软件版本。  </mark>  
每一次设计都包括，计划，建模，需求，分析和设计，实现，测试，评估等活动。  
每次迭代开始于计划和需求，结束于一个小型的发布，其内部就像一个小的瀑布模型，就是说，瀑布模型可以看作是迭代化开发的一个特例。  
整个开发流程只有一次迭代。  
唯一和瀑布模型不同的是，其计划，需求，设计，实现，测试，等活动，允许（或鼓励）部分并行的进行。


原则二：  
<mark style="background: #BBFABBA6;">要有计划的进行迭代。</mark>采用瀑布模型进行开发也有迭代。  
迭代化开发要求在做项目计划的时候就确定迭代的次数，以及每次迭代的起止时间和任务。【有计划的，不失控的】  
一个软件项目通常由 3-9 个迭代组成，项目的风险越高，迭代就越多。迭代的安排和计划是由风险驱动的。


原型模型 和 螺旋模型的区别。

![image.png](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250306190838259.png)

两者都属于**演化模型**，但原型模型更适合用户体验优化，而螺旋模型更适合高风险、高可靠性的软件开发。


【原型模型】

用户定义了软件的一组目标，但是不能标识出详细的需求。  
或者开发者不能确定算法的有效性、操作系统的适应性或者人机交互的形式。  
这种情况下，prototype model 可能就是最好的徐总呢。  
原型模型就是迭代次数为 2 的演化模型。

开发者和客户一起定义软件的总体目标，标识出已知的需求，然后进行快速的设计和实现。  
开发得到的原型交给客户进行评估，进一步的精化待开发软件的需求，逐步的调整原型使其满足客户的需求。  
![Screenshot_20250305_201559_Samsung capture.jpg](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250305201743868.jpg)

原型模型存在的问题：

- 不切实际的进度和费用预算：用户可能以为最终产品的开发也能够和开始的快速开发原型过程 一样的进度和费用实现。
- 建立原型的时间太长。原型模型是一种试探性的，不断反复的过程，因此必须采用快速开发的实践来开发原型。
- 设计欠佳。软件产品会根据客户的反馈不断的进行调整，变更需求，甚至改变产品的方向。如果 在设计的时候没有预见到这种情况，并且没有进行重新的设计，或者在进行原型设计的时候只关心用户界面，那么软件产品的设计就会恶化，可维护性就会越来越差。


【螺旋模型】

也是一种演化软件过程模型，在螺旋模型中，软件开发是一系列的迭代，在早期的迭代中，开发的可能是一个纸上的模型或者原型；  
在之后的迭代中，将逐步的产生更加完善的版本。

![Screenshot_20250305_202429_Samsung capture.jpg](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250305202442567.jpg)

对于大型系统和软件的开发来说，螺旋模型是一个很现实的方法。因为软件随着过程的进展演化，开发者和用户能够更好的理解和对待每一个演化级别上的风险。  
螺旋模型使用原型作为降低风险的机制，但是更加重要的是，他使得开发者在产品的演化的任何一个阶段都可以使用原型方法。  
他保持了传统生命周期模型中的系统的，阶段性的方法，但是将其并进了迭代框架，更加真实的反映了现实世界。  
螺旋模型要求在项目的所有阶段直接考虑技术风险，如果应用得当，能够在风险变成问题之前减小他的危害。

但是和其他范型一样，螺旋模型也不是包治百病的，他可能难以使用户（尤其在合同情况下）相信演化方法是可控的。  
他需要相应的风险评估的专门技术，且其成功依赖于这种专门技术。  
如果一个大的风险没有被发现和管理，毫无疑问会出现问题。

## 统一软件过程。RUP

每一种软件生命周期都有具体的过程实例，其中统一软件过程（unified process）是目前得到最广泛接受的软件过程。  
UP 是 一个 风险驱动的、基于 UML 和构件式架构的迭代、演化开发过程，他从几千个软件项目的实践经验汇总总结而来，对实际项目具有很强的指导意义。


UP 包括以下三大部分：

- 一整套成功开发软件的原理和最佳实践。
- 过程模型和相关的内容模板库。
- 过程定义工具。

### 阶段

- 先启 inception：
	- 在所有项目干系人之间就项目的目标达成共识。
- 精化 elaboration：
	- 建立软件架构的基线，解决技术风险，以便为软件的详细设计和实现提供一个稳定的基础。
- 构建 construction
	- 基于已经建立基线的架构完成系统开发。从某种意义上来说是一个制造的过程。
- 产品化 transition
	- 确保最终用户可以使用软件。

每个阶段  的结束标志就是一个业务决策里程碑。 （大）

### 迭代

UP 的每一个阶段都可以细分为若干个迭代，每一个迭代的结束标志是一个技术里程碑。 （小）

- 增量式
- 演进式
- 增量提交
- 单次迭代

### 过程规范

- 业务建模
- 需求
- 分析设计
- 实现
- 测试
- 部署

UP 定义的三个支持规范：

- 配置与变更管理
- 项目管理
- 环境

## 敏捷过程

强调以人为本，快速的响应需求和变化，把注意力集中到项目的主要目标——可用软件上。  
在保证质量的前提下，做到文档、度量适度。  

【很容易适应变化并迅速的做出自我调整，在保证质量的前提下，实现企业效益的最大化】  
【在保证软件开发有成功产出的前提下，尽量减少开发过程中的活动和制品 just enough】

![image.png](https://raw.githubusercontent.com/psychonaut1f/mac/main/2025/20250306191302321.png)

### scrum

Scrum 是一种**敏捷开发框架**，用于管理复杂软件项目，强调**迭代开发**、**快速交付**和**团队协作**。它的核心理念是：**把项目拆成多个短周期（Sprint），在每个 Sprint 结束时交付一个可用的增量产品**，并不断改进。

Scrum 适用于需求经常变化、需要快速响应市场的项目，比如互联网应用、移动应用、企业软件开发等。


Scrum 由**角色（Roles）、事件（Events）、工件（Artifacts）三大部分组成。

#### **🔹 角色（Roles）**

Scrum 团队一般由以下三种角色组成：

1. **产品负责人（Product Owner，PO）**
    
    - 负责定义产品需求，并优先级排序。
    - 决定产品待办列表（Product Backlog）的内容。
    - 确保开发团队做的是最重要的事情。
2. **Scrum Master**
    
    - **教练 + 协调员**，帮助团队遵循 Scrum 方法。
    - 解决团队的障碍，保证开发流程顺畅。
    - 促进团队内部沟通，确保团队高效运作。
3. **开发团队（Development Team）**
    
    - 负责实际开发、测试、设计和交付产品。
    - **自组织**，没有传统的“项目经理”角色，每个人都需要参与决策。
    - 在每个 Sprint 结束时，交付一个可用的软件增量。

#### **🔹 事件（Events）**

Scrum 开发过程围绕一系列固定的事件展开，以保证高效协作和持续改进：

1. **Sprint（冲刺）**
    
    - **一个 Scrum 开发周期，通常 1~4 周**。
    - 团队在 Sprint 内完成一个**可交付的产品增量**。
    - Sprint 期间**不允许改变目标**，保证团队专注开发。
2. **Sprint 计划会议（Sprint Planning）**
    
    - 由整个团队一起制定 Sprint 目标。
    - 选择本次 Sprint 要完成的任务。
    - 任务来自**产品待办列表（Product Backlog）**。
3. **每日站会（Daily Scrum / Standup）**
    
    - **每天 15 分钟**的站立会议，团队成员汇报：
        1. 我昨天做了什么？
        2. 我今天打算做什么？
        3. 有什么阻碍我的工作？
    - 目的是同步进度，快速发现问题。
4. **Sprint 评审（Sprint Review）**
    
    - Sprint 结束时，团队向 PO 和其他相关人员展示本次 Sprint 的成果。
    - 收集反馈，决定下一步如何改进。
5. **Sprint 回顾（Sprint Retrospective）**
    
    - 复盘整个 Sprint，讨论：
        1. 哪些做得好？
        2. 哪些可以改进？
        3. 下个 Sprint 如何优化？
    - 目的是不断改进开发流程，提高团队效率。

---

#### **🔹 工件（Artifacts）**

Scrum 的工件（产出物）是团队开发过程中用到的重要工具：

1. **产品待办列表（Product Backlog）**
    
    - 由 PO 维护的任务列表，包含所有待开发的功能。
    - 任务按照**优先级排序**，团队会优先完成最重要的任务。
2. **Sprint 待办列表（Sprint Backlog）**
    
    - 从产品待办列表中选出的**当前 Sprint 要完成的任务**。
    - 这些任务是开发团队承诺在 Sprint 结束前完成的。
3. **增量（Increment）**
    
    - 每次 Sprint 完成的**可交付、可用的软件版本**。
    - 目标是**持续交付**，让产品逐步完善。
    
	
	
**Scrum 的工作流程**

Scrum 的整个流程可以总结为：

1. **产品负责人创建并维护产品待办列表（Product Backlog）**
2. **团队在 Sprint 计划会议上选择本次 Sprint 要完成的任务**
3. **每天进行 15 分钟的 Daily Scrum，检查进度**
4. **Sprint 结束后，进行 Sprint 评审，展示成果**
5. **Sprint 结束后，进行 Sprint 回顾，优化流程**
6. **进入下一个 Sprint，重复循环**

**简单来说：**

- **持续迭代**：每次 Sprint 都交付一个可用版本。
- **快速反馈**：通过评审和回顾不断优化。
- **自组织团队**：开发团队自己管理工作，提高效率。


Scrum 在中文中通常翻译为 **" 敏捷开发框架 "** 或 **"Scrum 框架 "**，但如果直译的话，Scrum 的意思是 **" 争球 "**（源自橄榄球术语）。

- Scrum 这个词最早来自橄榄球，指的是**球员紧密协作，推动比赛进程**的战术。
- 在软件开发中，Scrum 借用了这种**团队协作、快速推进**的概念，强调**高效协作、快速交付、持续改进**。

所以，虽然 **Scrum 可以直译为 " 争球 "**，但在软件开发领域，它通常不翻译，直接使用 **"Scrum"** 一词，或者称为 **"Scrum 框架 "**、**"Scrum 方法 "**。

### xp extreme programming 极限编程

高度动态的过程。通过非常短的迭代周期来应对需求的变化。  
一般适用于需求不确定，变化快，项目历时不超过半年， 而人数不超过 10 个，同一个地点工作的中小型团队。

xp 提供了一个全局的，价值驱动的开发过程视图。体现了四个价值目标：
- 沟通
- 简化
- 反馈
- 勇气

![image.png](https://raw.githubusercontent.com/psychonaut1f/2025/main/825/20250317211633683.png)
